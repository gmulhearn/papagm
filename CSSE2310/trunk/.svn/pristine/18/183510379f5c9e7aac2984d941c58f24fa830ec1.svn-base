#include "2310sharedPlayer.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

//puts an error message to stderr given a certain error Status int
//Returns: the same Status that was inputted
Status show_message(Status s) {
    const char* messages[] = {"",
            "Usage: player players myid threshold handsize\n",
            "Invalid players\n",
            "Invalid position\n",
            "Invalid threshold\n",
            "Invalid hand size\n",
            "Invalid message\n",
            "EOF\n"};

    fputs(messages[s], stderr);
    return s;
}

//checks if the provided string is an integer
//Returns: true if string can be converted to an int, false otherwise
bool check_if_num(char* string) {
    for (int i = 0; i < strlen(string); i++) {
        if (string[i] - '0' < 0 || string[i] - '0' > 9) {
            return false;
        }
    }
    return true;
}

//checks if the provided 2 chars are valid to be a suit and rank of a card
//Returns: true if suit and rank characters are valid, false otherwise
bool check_valid_card(char suit, char rank) {
    if (suit != 'S' && suit != 'C' && suit != 'D' && suit != 'H') {
        return false;
    }
    if (!((rank >= '1' && rank <= '9') || (rank >= 'a' && rank <= 'f'))) {
        return false;
    }
    return true;
}

//checks the basic intial arguments (argc) against several constraints
//Returns: the first line of stdin (should be the players hand if hub works).
//Throws error: if any of the arguments or first line of stdin are incorrect.
char* check_basic_args(int argv, char** argc) {
    
    if (argv != 5) {
        exit(show_message(INCORRECT_NUM_ARGS));
    }
    if (!check_if_num(argc[1]) || atoi(argc[1]) < 2) {
        exit(show_message(INVALID_NUM_PLAYERS));
    }
    if (!check_if_num(argc[2]) || atoi(argc[2]) > atoi(argc[1]) - 1) {
        exit(show_message(INVALID_POSITION));
    }
    if (!check_if_num(argc[3]) || atoi(argc[3]) < 2) {
        exit(show_message(INVALID_THRESHOLD));
    }
    if (!check_if_num(argc[4]) || atoi(argc[4]) < 1) {
        exit(show_message(INVALID_HAND_SIZE));
    }
    char* firstMsg = read_stdin();
    if (interpret_msg(firstMsg) != 1) {
        exit(show_message(INVALID_MSG));
    }

    return firstMsg;

    //fprintf(stdout, "@");
    //fflush(stdout);
}

//reads stdin until the first new line character
//Returns: a string of what it read until the new line character
//Throws Error: if stdin contained an EOF character
char* read_stdin(void) {
    char* string = malloc(sizeof(char) * 420); //fix buffer
    char currCharacter = ' ';
    int count = 0;

    while (1) {
        currCharacter = fgetc(stdin);
        if (currCharacter == EOF) {
            exit(show_message(UNEXPECTED_EOF));
        }
        if (currCharacter == '\n') {
            string[count] = '\0';
            return string;
        } else {
            string[count] = currCharacter;
            count++;
        }
    }
}

//interprets the string and determines what type of message it is.
//Returns: 1 if string is a message beginning with HAND
// 2 if message begins with PLAYED
// 3 if message begins with NEWROUND
// 4 if message begins with GAMEOVER
//Throws Error: if none of these four cases.
int interpret_msg(char* hubMsg) {
    const char* hand = "HAND";
    const char* newRound = "NEWROUND";
    const char* played = "PLAYED";
    const char* gameover = "GAMEOVER";

    if (!strncmp(hubMsg, hand, 4)) {
        //interpret_hand(hubMsg);
        return 1;
    } else if (!strncmp(hubMsg, played, 6)) {
        //interpret move
        return 2;
    } else if (!strncmp(hubMsg, newRound, 8)) {
        //interpret round
        return 3;
    } else if (!strncmp(hubMsg, gameover, 8)) {
        //intrpet game over
        return 4;
    } else {
        exit(show_message(INVALID_MSG));
    }
}

//given a string message and the Game Struct, decode the message into a Hand
//Returns: a hand struct with cards and length from the message
//Throws error: if incorrectly formatted message (i.e. not HANDn,SR,SR,..,SR)
Hand interpret_hand(char* hubMsg, Game game) {
    char handSize[69]; //fix
    int counter = 4;

    for (int i = 0; i < 69; i++) {
        if (hubMsg[i + 4] == ',') {
            handSize[i] = '\0';
            break;
        } else if (hubMsg[i + 4] == '\0') {
            exit(show_message(INVALID_MSG));
            break;
        } else {
            handSize[i] = hubMsg[i + 4];
        }
        counter++;
    }
    if (!check_if_num(handSize)) {
        exit(show_message(INVALID_MSG));
    }
    if (atoi(handSize) != game.givenHandSize) {
        exit(show_message(INVALID_MSG));
    }
    printf("%d%d",atoi(handSize), game.player.hand.size);
    Hand hand;
    Card* cards = malloc(sizeof(Card) * atoi(handSize));
    for (int i = 0; i < atoi(handSize); i++) {
        Card card;
        if (hubMsg[counter++] != ',') {
            exit(show_message(INVALID_MSG));
        } 
        card.suit = hubMsg[counter++];
        if (!check_valid_card(card.suit, '2')) {
            exit(show_message(INVALID_MSG));
        }
        card.rank = hubMsg[counter++];
        if (!check_valid_card(card.suit, card.rank)) {
    
            exit(show_message(INVALID_MSG));
        }
        card.used = 0;
        cards[i] = card;
    }
    if (hubMsg[counter++] != '\0') {
        exit(show_message(INVALID_MSG));
    }
    hand.cards = cards;
    hand.size = atoi(handSize);

    return hand;
}

//Initializes the player given initial arguments, the game struct and handMsg
//Returns: player struct constructed with all given arguments
Player init_player(int argv, char** argc, Game* game, char* handMsg) {
    Player player;
    player.myID = atoi(argc[2]);
    game->numPlayers = atoi(argc[1]);
    game->threshold = atoi(argc[3]);
    player.hand = interpret_hand(handMsg, *game);

    return player;
}

//initializes the game information given the arguments
//Returns: game struct constructed with all given arguments
Game init(int argv, char** argc) {
    Game game;
    char* handMsg = check_basic_args(argv, argc);
    game.givenHandSize = atoi(argc[4]);
    game.player = init_player(argv, argc, &game, handMsg);
    printf("@");
    fflush(stdout);

    return game;
}

//converts a hand struct into a string (used for debugging purposes)
//Returns: string format of the provided Hand struct
char* hand_to_string(Hand* playerHand) {

    char* string = malloc(sizeof(char) * 4 * playerHand->size);
    strcpy(string, "");
    char suitRank[4];

    for (int i = 0; i < playerHand->size; i++) {
        sprintf(suitRank, "%d%c%c ", playerHand->cards[i].used,
                playerHand->cards[i].suit, 
                playerHand->cards[i].rank);
        strcat(string, suitRank);
    }

    return string;
}

//prints the current game and player info for debugging purposes
void print_info(Game game) {
    printf("\n\nGame: numPlayers - %d, threshold - %d \n",
            game.numPlayers, game.threshold);
    printf("Player: myID - %d \n", game.player.myID);
    printf("Hand: size - %d \n", game.player.hand.size);
    printf("Current Hand - %s \n\n", hand_to_string(&(game.player.hand)));
}

//plays a card at a certain index on the players hand (relies of prior checks)
//sends the played card to stdout in format "PLAYSR"
void play_card(int cardIndex, Game* game) {
    game->player.hand.cards[cardIndex].used = 1;

    char* string = malloc(sizeof(char) * 6);
    char suitRank[3];

    strcpy(string, "PLAY");
    sprintf(suitRank, "%c%c", game->player.hand.cards[cardIndex].suit,
            game->player.hand.cards[cardIndex].rank);
    strcat(string, suitRank);

    printf(string);
    fflush(stdout);

}

//given a certain hubMsg, determine whether it is the players turn now
//
bool is_my_turn(char* hubMsg, Game game) {
    int numPlayers = game.numPlayers;
    int myID = game.player.myID;
    char pNum[420]; //fix
    char terminator;
    int pos, origin;
    if (interpret_msg(hubMsg) == 2) {
        pos = 6;
        terminator = ',';
    } else if (interpret_msg(hubMsg) == 3) {
        pos = 8;
        terminator = '\0';
    }
    origin = pos;

    while (1) {
        if (hubMsg[pos] == '\0' && origin != 8) { 
            exit(show_message(INVALID_MSG)); //indicates invalid PLAYED msg
        }
        if (hubMsg[pos] == terminator) {
            pNum[pos-origin] = '\0';
            break;
        }
        else {
            pNum[pos-origin] = hubMsg[pos];
            pos++;
        }
    }
    if (!check_if_num(pNum)) {
        exit(show_message(INVALID_MSG));
    }
    if ((atoi(pNum) + 1) % numPlayers == myID) {
        return true;
    } else {
        return false;
    }
}

