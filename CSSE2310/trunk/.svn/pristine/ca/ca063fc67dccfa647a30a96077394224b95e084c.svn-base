#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <limits.h>
#include <math.h>
#include <signal.h>

#include <pthread.h>
#include <netdb.h>

typedef enum {
    NORMAL_EXIT = 0,
    INVALID_NUM_ARGS = 1,
    INVALID_NAME = 2,
    INVALID_QUANTITY = 3
} Status;

typedef enum {
    CONNECT = 0,
    IM = 1,
    DELIVER = 2,
    WITHDRAW = 3,
    TRANSFER = 4,
    DEFER_DELIVER = 5,
    DEFER_WITHDRAW = 6,
    DEFER_TRANSFER = 7,
    EXECUTE = 8,
    INVALID = 9
} Message;

Status show_message(Status s) {
    const char* messages[] = {"",
        "Usage: 2310depot name {goods qty}\n",
        "Invalid name(s)\n",
        "Invalid quantity\n"};
    fputs(messages[s], stderr);
    return s;
}

typedef struct {
    char* name;
    int quantity;
} Resource;

typedef struct {
    unsigned long port;
    char* name;
} Neighbour;

typedef struct {
    char* name;

    Resource* resources;
    int numResources;

    Neighbour* neighbours;
    int numNeighbours;
} Depot;

typedef struct {
    Depot* depot;
    int fd;
} ThreadPackage;

void process_transaction(Depot* depot, char* msg,int type);
Message process_msg(Depot* depot, char* msg);
void process_IM(Depot* depot, char* msg);


//global depot
Depot* globalDepot;



/** NETWORKING **/

void* connection(void* v) {
    ThreadPackage package = *(ThreadPackage*) v;
    Depot* depot = package.depot;
    
    int fd2 = dup(package.fd);
    FILE* to = fdopen(package.fd, "w");
    FILE* from = fdopen(fd2, "r");
    
    char msg[80];
    fgets(msg, 79, from);

    while (!feof(from)) {
        //fprintf(stdout, "%s", msg);
        //fflush(stdout);
        process_msg(depot, msg);
        fgets(msg, 79, from);
    }
    //printf("connection gone\n");
    //fflush(stdout);
    return (void*)0;
}

void host(Depot* depot) {
    struct addrinfo* ai = 0;
    struct addrinfo hints;
    memset(& hints, 0, sizeof(struct addrinfo));
    hints.ai_family=AF_INET;        // IPv6  for generic could use AF_UNSPEC
    hints.ai_socktype=SOCK_STREAM;
    hints.ai_flags=AI_PASSIVE;  // Because we want to bind with it    
    int err;
    if (err=getaddrinfo("127.0.0.1", 0, &hints, &ai)) { // no particular port
        freeaddrinfo(ai);
        fprintf(stderr, "%s\n", gai_strerror(err));
        exit(10);   // could not work out the address fix
    } 
    // create a socket and bind it to a port
    int serv = socket(AF_INET, SOCK_STREAM, 0); // 0 == use default protocol
    if (bind(serv, (struct sockaddr*)ai->ai_addr, sizeof(struct sockaddr))) {
        perror("Binding");
        exit(10); //fix
    } 
    // Which port did we get?
    struct sockaddr_in ad;
    memset(&ad, 0, sizeof(struct sockaddr_in));
    socklen_t len=sizeof(struct sockaddr_in);
    if (getsockname(serv, (struct sockaddr*)&ad, &len)) {
        perror("sockname");
        exit(10); //fix
    }
    printf("%u\n", ntohs(ad.sin_port));
    fflush(stdout); 
    if (listen(serv, 10)) { // allow up to 10 connection requests to queue
        perror("Listen");
        exit(10); //fix
    } 
    int conn_fd;
    pthread_t tid;
    //main thread loop here
    while (conn_fd = accept(serv, 0, 0), conn_fd >= 0) {    // change 0, 0 to get info about other end
        ThreadPackage package;
        package.depot = depot;
        package.fd = conn_fd;
        pthread_create(&tid, 0, connection, &package);
    }
    exit(10); //fix
}

/**    END     **/



bool is_num(char* string) {
    for (int i = 0; i < strlen(string); i++) {
        if (string[i] - '0' < 0 || string[i] - '0' > 9) {
            if (!(i == 0 && string[i] == '-')) { //unless negative
                return false;
            }
        }
    }
    if (strlen(string) == 0) {
        return false;
    }
    return true;
}

bool is_valid_name(char* string) {
    for (int i = 0; i < strlen(string); i++) {
        char c = string[i];
        if (c == ' ' || c == '\n' || c == '\r' || c == ':') {
            return false;
        }
    }
    return true;
}

//only used as a debugging tool
char* read_stdin(void) {
    char* string = malloc(sizeof(char) * 420); //fix buffer
    char currCharacter = ' ';
    int count = 0;

    while (1) {
        currCharacter = fgetc(stdin);
        if (currCharacter == EOF) {
            //err
        }
        if (currCharacter == '\n') {
            string[count] = '\0';
            return string;
        } else {
            string[count] = currCharacter;
            count++;
        }
    }
}

//starting from *pos, read string until it encounters the c character
//(or end of string)
//returns the string it read
char* read_until_char(char c, int* pos, char* msg) {

    int count = 0;
    char* string = malloc(sizeof(char) * 420); //fix buffer

    while (1) {
        char currCharacter = msg[*pos];
        if (currCharacter == '\0') {
            return string; //error handle here
        }
        if (currCharacter == c) {
            string[count] = '\0';
            return string;
        } else {
            string[count] = currCharacter;
            count++;
            *pos += 1;
        }
    }
}

int compare_resources(const void* v1, const void* v2) {
    Resource r1 = *((Resource*) v1);
    Resource r2 = *((Resource*) v2);
    char* name1 = r1.name;
    char* name2 = r2.name;

    return strcmp(name1, name2);
}

int compare_neighbours(const void* v1, const void* v2) {
    Neighbour n1 = *((Neighbour*) v1);
    Neighbour n2 = *((Neighbour*) v2);
    char* name1 = n1.name;
    char* name2 = n2.name;

    return strcmp(name1, name2);
}

Depot* process_args(int argv, char** argc) {
    Depot* depot = malloc(sizeof(Depot));

    depot->numNeighbours = 0;
    depot->neighbours = malloc(sizeof(Neighbour) * 1); //will need realloc

    if (argv < 2 || (argv / 2) * 2 != argv) { //double check
        exit(show_message(INVALID_NUM_ARGS));
    } else {
        depot->numResources = (argv - 2)/2;
        depot->resources = malloc(sizeof(Resource) * depot->numResources);
    }

    if (!is_valid_name(argc[1])) {
        exit(show_message(INVALID_NAME));
    } else {
        depot->name = argc[1];
    }

    for (int i = 2; i < argv; i += 2) { //checking names
        if (!is_valid_name(argc[i])) {
            exit(show_message(INVALID_NAME));
        } else {
            depot->resources[(i - 2)/2].name = argc[i];
        }
    }
    for (int i = 3; i < argv; i += 2) { //checking quantities
        if (!is_num(argc[i]) || atoi(argc[i]) < 0) {
            exit(show_message(INVALID_QUANTITY));
        } else {
            depot->resources[(i - 3)/2].quantity = atoi(argc[i]);
        }
    }

    return depot;
}

Message process_msg(Depot* depot, char* msg) {
    const char* connect = "Connect";
    const char* im = "IM";
    const char* deliver = "Deliver";
    const char* withdraw = "Withdraw";
    const char* transfer = "Transfer";
    const char* defer = "Defer";
    const char* execute = "Execute";

    //to do : error handling
    if (!strncmp(msg, im, 2)) {
        process_IM(depot, msg);
        return IM;
    } else if (!strncmp(msg, defer, 5)) {
        //return DEFER; //need to differ the types of defer
    } else if (!strncmp(msg, connect, 7)) {
        return CONNECT;
    } else if (!strncmp(msg, deliver, 7)) {
        process_transaction(depot, msg, 0);
        return DELIVER;
    } else if (!strncmp(msg, execute, 7)) {
        return EXECUTE;
    } else if (!strncmp(msg, withdraw, 8)) {
        process_transaction(depot, msg, 1);
        return WITHDRAW;
    } else if (!strncmp(msg, transfer, 8)) {
        return TRANSFER;
    } else {
        return INVALID;
    }
    return INVALID;
}

//checks if the depot provided has the resource type given by the type string
//returns the index of depot->resources that matches the type
// or -1 if no match
int has_type(Depot* depot, char* type) {
    for (int i = 0; i < depot->numResources; i++) {
        if (strcmp(type, depot->resources[i].name) == 0) {
            return i;
        }
    }
    return -1;
}

//used for delivering and withdrawing messages
//type 0 = deliver
//type 1 = withdraw
void process_transaction(Depot* depot, char* msg, int type) {
    int pos = 8 + type;
    char* q = read_until_char(':', &pos, msg);
    pos++;
    char* t = read_until_char('\0', &pos, msg);
    if (t[strlen(t) - 1] == '\n') {
        t[strlen(t) - 1] = '\0';
    }

    if (is_num(q)) {
        if (has_type(depot, t) != -1) {
            depot->resources[has_type(depot, t)].quantity += atoi(q);
        } else { //new resource
            depot->numResources++;
            depot->resources = realloc(depot->resources,
                    sizeof(Resource) * depot->numResources);

            Resource newResource;
            newResource.name = t;
            if (type == 0) {
                newResource.quantity = 0 + atoi(q);
            } else {
                newResource.quantity = 0 - atoi(q);
            }
            depot->resources[depot->numResources - 1] = newResource;
            qsort(depot->resources, depot->numResources, 
                    sizeof(Resource), compare_resources);
        }
    } else {
        return; //ignore
    }
}

void process_IM(Depot* depot, char* msg) {
    depot->numNeighbours++;
    depot->neighbours = realloc(depot->neighbours, 
            sizeof(Neighbour) * depot->numNeighbours);

    int pos = 3;
    char* p = read_until_char(':', &pos, msg);
    pos++;

    char* name = read_until_char('\0', &pos, msg);
    if (p[strlen(p) - 1] == '\n') {
        p[strlen(p) - 1] = '\0';
    }

    Neighbour newNeighbour;
    if (is_num(p)) {
        newNeighbour.port = atoi(p);
        newNeighbour.name = name;
        depot->neighbours[depot->numNeighbours - 1] = newNeighbour;
        qsort(depot->neighbours, depot->numNeighbours,
                sizeof(Neighbour), compare_neighbours);
    } else {
        return;
    }
}

char* hangup_msg(Depot* depot) {
    char* msg = malloc(sizeof(char) * 420); //fix
    strcpy(msg, "Goods:\n");
    for (int i = 0; i < depot->numResources; i++) {
        char resourceStr[69]; //fix
        Resource resource = depot->resources[i];
        sprintf(resourceStr, "%s %d\n", resource.name, resource.quantity);   
        strcat(msg, resourceStr);
    }
    strcat(msg, "Neighbours:\n");
    for (int i = 0; i < depot->numNeighbours; i++) {
        char neighbourStr[69]; //fix
        Neighbour neighbour = depot->neighbours[i];
        if (i == depot->numNeighbours - 1) {
            sprintf(neighbourStr, "%s", neighbour.name);
        } else {
            sprintf(neighbourStr, "%s\n", neighbour.name);
        }
        strcat(msg, neighbourStr);
    }

    return msg;
}

void handler(int s) {
    printf(hangup_msg(globalDepot));
    fflush(stdout);
}

int main(int argc, char** argv) {

    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = SA_RESTART; //fix
    sigaction(SIGHUP, &sa, 0);

    Depot* depot = process_args(argc, argv);
    
    globalDepot = depot;

    host(depot);

    //printf(depot->name);
    
    //while (1) {
    //    process_deliver(depot, read_stdin());
    //}

    return 0;
}




